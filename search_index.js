var documenterSearchIndex = {"docs":
[{"location":"kernelTools/#Kernel-Tools","page":"Kernel Tools","title":"Kernel Tools","text":"","category":"section"},{"location":"kernelTools/","page":"Kernel Tools","title":"Kernel Tools","text":"Some tools to set up a solver that uses kernel methods.","category":"page"},{"location":"kernelTools/#Functions","page":"Kernel Tools","title":"Functions","text":"","category":"section"},{"location":"kernelTools/","page":"Kernel Tools","title":"Kernel Tools","text":"exponentialKernel(x::Vector, y::Vector; h = 1)\ngramian(kernel::Function, Y::Vector{<:Vector})\nkernelNorm(weights::Vector, kernelGramian::Matrix)\nkernelFunction(\n\t\tkernel::Function,\n\t\tweights::Vector,\n\t\tY::Vector{<:Vector},\n\t\tx::Vector,\n\t)\ndensityConditionalMean(kernel::Function, Y::Vector, X::Vector, y::Any, h::Float64)\nkernelInterpolation(\n\t\tkernel::Function,\n\t\tY::Vector,\n\t\tO::Vector;\n\t\tλ = 0.5,\n\t)","category":"page"},{"location":"kernelTools/#QuadraticTeamDecisionSolver.exponentialKernel-Tuple{Vector, Vector}","page":"Kernel Tools","title":"QuadraticTeamDecisionSolver.exponentialKernel","text":"exponentialKernel(x::Vector, y::Vector; h = 1)\n\nRadial Basis Function Kernel \n\nArguments:\n\nx::Vector: A data sample.\nx::Vector: Also a data sample.\nh=1: Width of the kernel.\n\nReturns:\n\nValue of the kernel computed at x and y with window width h, \n\nthat is, exp left( - fracx - y^2h right) where   cdot   is the norm  on the original sample space.\n\n\n\n\n\n","category":"method"},{"location":"kernelTools/#QuadraticTeamDecisionSolver.gramian-Tuple{Function, Vector{<:Vector}}","page":"Kernel Tools","title":"QuadraticTeamDecisionSolver.gramian","text":"gramian(kernel::Function, Y::Vector{<:Vector})\n\nCompute the gramian of a kernel K over the samples mathbfY subset mathcalY.\n\nArguments:\n\nkernel::Function: A positive definite kernel function.\nY::Vector{<:Vector}: The samples over which the gramian is to be constructed.\n\n\n\n\n\n","category":"method"},{"location":"kernelTools/#QuadraticTeamDecisionSolver.kernelNorm-Tuple{Vector, Matrix}","page":"Kernel Tools","title":"QuadraticTeamDecisionSolver.kernelNorm","text":"kernelNorm(weights::Vector, kernelGramian::Matrix)\n\nCompute the function norm: sum_l=1^m sum_k=1^m alpha_l alpha_k K( mathbfy_l mathbfy_k ) of a function in a reproducing kernel Hilbert space. Th\n\nArguments:\n\nweights::Vector: The alpha's in the above expression.\nkernelGramian::Matrix: The gramian of K over the samples mathbfY\n\n\n\n\n\n","category":"method"},{"location":"kernelTools/#QuadraticTeamDecisionSolver.kernelFunction-Tuple{Function, Vector, Vector{<:Vector}, Vector}","page":"Kernel Tools","title":"QuadraticTeamDecisionSolver.kernelFunction","text":"kernelFunction(\n\tkernel::Function,\n\tweights::Vector,\n\tY::Vector{<:Vector},\n\tx::Vector,\n)\n\nEvaluates a kernel function of the form f(mathbfy) = sum_l=1^m alpha_l K(mathbfy mathbfy_(l))\n\nArguments:\n\nkernel::Function Kernel function that defines the RKHS where f lives.\nweights: The alpha's in the above expression.\ny: The point mathbfy in mathcalY at which f is to be evaluated.\n\n\n\n\n\n","category":"method"},{"location":"kernelTools/#QuadraticTeamDecisionSolver.densityConditionalMean-Tuple{Function, Vector, Vector, Any, Float64}","page":"Kernel Tools","title":"QuadraticTeamDecisionSolver.densityConditionalMean","text":"densityConditionalMean(kernel::Function, Y::Vector, X::Vector, y::Any, h::Float64)\n\nComputes an estimate of a conditonal expectation of the form mathbbEmathbfXmathbfY = y\n\n\n\n\n\n","category":"method"},{"location":"kernelTools/#QuadraticTeamDecisionSolver.kernelInterpolation-Tuple{Function, Vector, Vector}","page":"Kernel Tools","title":"QuadraticTeamDecisionSolver.kernelInterpolation","text":"kernelInterpolation(\n\tkernel::Function,\n\tY::Vector,\n\tO::Vector;\n\tλ = 0.5,\n)\n\nSolves the regularized interpolation problem:\n\nbeginalign*\n\t\ttextfind  f^* in argmin_f in mathcalH_k fraclambda2 lvert lvert f rvert rvert_mathcalH_k^2 \n\t\ttextsuch that  f(mathbfy^(l)) = mathbfo^(l)  qquad l in 1 dots m\nendalign*\n\nWhere mathcalH_k is a Reproducing Kernel Hilbert Space with kernel k.\n\nArguments:\n\nkernel::Function: The kernel function that corresponds to mathcalH_k.\nY::Vector: Vector of samples in input space mathcalY.\nO::Vector: Vector of samples in output space mathcalO.\nλ = 0.5: Regularization constant for ridge regression.\n\nNote that Y::Vector and O::Vector must have the same length m.\n\n\n\n\n\n","category":"method"},{"location":"fixedPointSolvers/#Fixed-Point-Solvers","page":"Fixed Point Solvers","title":"Fixed Point Solvers","text":"","category":"section"},{"location":"fixedPointSolvers/","page":"Fixed Point Solvers","title":"Fixed Point Solvers","text":"Methods and Interface for building solvers for the quadratic team decision problem using empirical  fixed point iterations.","category":"page"},{"location":"fixedPointSolvers/#Functions","page":"Fixed Point Solvers","title":"Functions","text":"","category":"section"},{"location":"fixedPointSolvers/","page":"Fixed Point Solvers","title":"Fixed Point Solvers","text":"generateCrossSamples(N::Int, i::Int, γ::Vector{<:Function}, Y::Vector{<:Vector}, R::Vector{<:Vector})\nparallelIterationSolver(\n\t\tp::QuadTeamProblem,\n\t\tS::Vector{<:Sample},\n\t\tfunctionClass::Vector{<:Function},\n\t\tfunctionNorms::Vector{<:Function},\n\t\toutputMap::Function,\n\t\tinterpolation::Function;\n\t\titerations = 5,\n\t\tpreprocessData = true,\n\t)\nGeneralOutputMap(\n\t\tY::Vector{<:Vector},\n\t\tcrossSamples::Vector,\n\t\tsquareBlocks::Vector,\n\t\tr::Vector,\n\t\tconditionalMean::Function\n\t)","category":"page"},{"location":"fixedPointSolvers/#QuadraticTeamDecisionSolver.generateCrossSamples-Tuple{Int64, Int64, Vector{<:Function}, Vector{<:Vector}, Vector{<:Vector}}","page":"Fixed Point Solvers","title":"QuadraticTeamDecisionSolver.generateCrossSamples","text":"generateCrossSamples(N::Int, i::Int, γ::Vector{<:Function}, Y::Vector{<:Vector}, R::Vector{<:Vector})\n\nGenerate cross samples for a quadratic team decision problem.\n\nArguments\n\nN::Int: Total number of agents in the problem.\ni::Int: Index of the current agent.\nγ::Vector{<:Function}: Vector of function class instances representing the decision variables.\nR::Vector{<:Vector}: Vector of vectors representing the data samples.\n\nReturns\n\ncrossSamples::Vector: Vector of cross samples for the current agent.\n\n\n\n\n\n","category":"method"},{"location":"fixedPointSolvers/#QuadraticTeamDecisionSolver.parallelIterationSolver-Tuple{QuadTeamProblem, Vector{<:Sample}, Vector{<:Function}, Vector{<:Function}, Function, Function}","page":"Fixed Point Solvers","title":"QuadraticTeamDecisionSolver.parallelIterationSolver","text":"parallelIterationSolver(\n\tp::QuadTeamProblem,\n\tS::Vector{<:Sample},\n\tfunctionClass::Vector{<:Function},\n\tfunctionNorms::Vector{<:Function},\n\toutputMap::Function,\n\tinterpolation::Function;\n\titerations = 5,\n\tpreprocessData = true,\n)\n\nApproximate the solution to a quadratic team decision problem using a parallel iteration scheme.\n\nArguments\n\np::QuadTeamProblem: A QuadTeamProblem object defining the problem's specifications.\nS::Vector{<:Sample}: A vector of Sample objects representing the data samples.\nfunctionClass::{<:Function}: A vector of functions that for each agent provides a function that constructs an instance of the function class used for optimization.\nfunctionNorm::{<:Function}: A vector of functions that for each agent provides a function that computes the norm of a function class instance.\noutputMap::Function: A function that maps performs conditional mean estimation.\ninterpolation::Function: A function that performs interpolation for updating the decision variables.\niterations::Int = 5: The number of fixed-point iterations to perform.\npreprocessData::Bool = true: Whether to perform data preprocessing and validation.\n\nReturns\n\nweights::Vector: A vector of weight vectors representing the decision variables at each iteration.\nnorms::Vector{Vector{Float64}}: A vector of vectors containing the norms of the weight vectors at each iteration for each agent.\nempiricalCost::Vector{Float64}: A vector containing the empirical cost at each iteration.\n\n\n\n\n\n","category":"method"},{"location":"fixedPointSolvers/#QuadraticTeamDecisionSolver.GeneralOutputMap-Tuple{Vector{<:Vector}, Vector, Vector, Vector, Function}","page":"Fixed Point Solvers","title":"QuadraticTeamDecisionSolver.GeneralOutputMap","text":"GeneralOutputMap(\n\tY::Vector{<:Vector},\n\tcrossSamples::Vector,\n\tsquareBlocks::Vector,\n\tr::Vector,\n\tconditionalMean::Function\n)\n\nComputes the output map for the agent i in the current iteration.\n\nArguments:\n\nSamples of mathbfY_i\nSamples of mathbfR_ij(mathbfX)gamma_(k)^j(mathbfY_j)\nSamples of mathbfR_ij\nSamples of mathbfr_i\nconditionalMean:A method to compute a contional mean of the form mathbbEmathbfXmathbfY=y\n\nUsage:\n\nPass an anonymous function of the form:\n\n\t(Yᵢ, Rᵢⱼ, Rᵢᵢ, rᵢ) -> GeneralOutputMap(Y, Rᵢⱼ, Rᵢᵢ, rᵢ, conditionalMean)\n\nas the outputMap argument to any of the fix point solvers. \n\nNote:\n\nCheck / fine tune argument types!\n\n\n\n\n\n","category":"method"},{"location":"fixedPointSolvers/#Detailed-Description-of-Function-Arguments-The-Solver-Takes","page":"Fixed Point Solvers","title":"Detailed Description of Function Arguments The Solver Takes","text":"","category":"section"},{"location":"fixedPointSolvers/#functionClass::Function","page":"Fixed Point Solvers","title":"functionClass::Function","text":"","category":"section"},{"location":"fixedPointSolvers/#Arguments","page":"Fixed Point Solvers","title":"Arguments","text":"","category":"section"},{"location":"fixedPointSolvers/","page":"Fixed Point Solvers","title":"Fixed Point Solvers","text":"weights: A vector that correspond to the basis function weights / function class parameters","category":"page"},{"location":"fixedPointSolvers/#Returns","page":"Fixed Point Solvers","title":"Returns","text":"","category":"section"},{"location":"fixedPointSolvers/","page":"Fixed Point Solvers","title":"Fixed Point Solvers","text":"f: A function in the hypothesis function class mathcalF.","category":"page"},{"location":"fixedPointSolvers/#Remarks","page":"Fixed Point Solvers","title":"Remarks","text":"","category":"section"},{"location":"fixedPointSolvers/","page":"Fixed Point Solvers","title":"Fixed Point Solvers","text":"This function is used to construct each entry of the solution function vector  γ, as such, great care must be taken that it can properly handle  vector valued outputs. Moreover the  interpolation and functionNorm methods must be tailor made to suit this function class.","category":"page"},{"location":"fixedPointSolvers/","page":"Fixed Point Solvers","title":"Fixed Point Solvers","text":"Note that during each iteration, samples of the random variable mathbfR_ijgamma_(k)^j(mathbfY_j) are approximately generated using the last estimate of gamma^j, so a very good choice of mathcalF is critical to the success of the scheme.","category":"page"},{"location":"fixedPointSolvers/#functionNorm::Function","page":"Fixed Point Solvers","title":"functionNorm::Function","text":"","category":"section"},{"location":"fixedPointSolvers/#Arguments-2","page":"Fixed Point Solvers","title":"Arguments","text":"","category":"section"},{"location":"fixedPointSolvers/","page":"Fixed Point Solvers","title":"Fixed Point Solvers","text":"weights: A vector that correspond to the basis function weights / function class parameters.","category":"page"},{"location":"fixedPointSolvers/#Returns-2","page":"Fixed Point Solvers","title":"Returns","text":"","category":"section"},{"location":"fixedPointSolvers/","page":"Fixed Point Solvers","title":"Fixed Point Solvers","text":"f: The function norm of the function f described by the weights weights.","category":"page"},{"location":"fixedPointSolvers/#interpolation::Function","page":"Fixed Point Solvers","title":"interpolation::Function","text":"","category":"section"},{"location":"fixedPointSolvers/#Arguments-3","page":"Fixed Point Solvers","title":"Arguments","text":"","category":"section"},{"location":"fixedPointSolvers/","page":"Fixed Point Solvers","title":"Fixed Point Solvers","text":"Y[i]: Measurement data for the agent i.\nO[i]: Output map data for the agent i.","category":"page"},{"location":"fixedPointSolvers/#Returns-3","page":"Fixed Point Solvers","title":"Returns","text":"","category":"section"},{"location":"fixedPointSolvers/","page":"Fixed Point Solvers","title":"Fixed Point Solvers","text":"weights: The weights that correspond to the function f in our function class mathcalF that best interpolates Y[i] and O[i].","category":"page"},{"location":"fixedPointSolvers/#Remarks-2","page":"Fixed Point Solvers","title":"Remarks","text":"","category":"section"},{"location":"fixedPointSolvers/","page":"Fixed Point Solvers","title":"Fixed Point Solvers","text":"As with functionClass, care most be taken that this can hanble both vector and scalar valued input and output data.","category":"page"},{"location":"fixedPointSolvers/#outputMap::Function","page":"Fixed Point Solvers","title":"outputMap::Function","text":"","category":"section"},{"location":"fixedPointSolvers/#Arguments-4","page":"Fixed Point Solvers","title":"Arguments","text":"","category":"section"},{"location":"fixedPointSolvers/","page":"Fixed Point Solvers","title":"Fixed Point Solvers","text":"Y[i]: Measurement data for the agent i. \ncrossSamples: generated sample data from the random variable given by: mathbfR_ijgamma_(k)^j(mathbfY_j).\nsquareBlocks: Samples from mathbfR_ii. These should be Hermitian and Positive Definite.\nr_blocks[i]: Samples from mathbfr_i","category":"page"},{"location":"fixedPointSolvers/#Returns-4","page":"Fixed Point Solvers","title":"Returns","text":"","category":"section"},{"location":"fixedPointSolvers/","page":"Fixed Point Solvers","title":"Fixed Point Solvers","text":"O: Vector of approximated samples of the random variable left( mathbbEmathbfR_iimathbfY_i right)^-1left( sum_ij=1    i neq j^N mathbbEmathbfR_ijgamma_(k)^j(mathbfY_j)mathbfY_i + mathbbEmathbfr_imathbfY_i right)","category":"page"},{"location":"fixedPointSolvers/#Remarks-3","page":"Fixed Point Solvers","title":"Remarks","text":"","category":"section"},{"location":"fixedPointSolvers/","page":"Fixed Point Solvers","title":"Fixed Point Solvers","text":"This method must have within it a method that estimates conditional expectations of the form mathbbEmathbfXmathbfY=y see: GeneralOutputMap(Y::Vector{<:Vector}, crossSamples::Vector{<:Vector}, squareBlocks::Vector{<:Matrix}, r::Vector{<:Vector}, conditionalMean::Function)","category":"page"},{"location":"fixedPointSolvers/","page":"Fixed Point Solvers","title":"Fixed Point Solvers","text":"Otherwise, an outputMap can also be implemented with a method that estimates conditional expectation operators of the form mathbbEmathbfXmathbfY.","category":"page"},{"location":"problemUtils/#General-Types-and-Utility-Functions","page":"General Utility Functions","title":"General Types and Utility Functions","text":"","category":"section"},{"location":"problemUtils/#Types","page":"General Utility Functions","title":"Types","text":"","category":"section"},{"location":"problemUtils/","page":"General Utility Functions","title":"General Utility Functions","text":"QuadTeamProblem{T<:Number}\nSample{T<:Number}","category":"page"},{"location":"problemUtils/#QuadraticTeamDecisionSolver.QuadTeamProblem","page":"General Utility Functions","title":"QuadraticTeamDecisionSolver.QuadTeamProblem","text":"QuadTeamProblem{T <: Number}\n\nThe QuadTeamProblem struct represents a quadratic team decision problem. In essence, it stores the correct problem dimensions and the field over which the problem is solved.\n\nFields\n\nN::Int: Number of agents in the team.\nm::Vector{Int}: Array of measurement dimensions for each agent.\na::Vector{Int}: Array of action space dimensions for each agent.\nT::Type{T}: Numeric type for the problem.\n\n\n\n\n\n","category":"type"},{"location":"problemUtils/#QuadraticTeamDecisionSolver.Sample","page":"General Utility Functions","title":"QuadraticTeamDecisionSolver.Sample","text":"Sample{T <: Number}\n\nThe Sample struct represents a sample data point for the quadratic team decision problem.\n\nFields\n\nY::Vector{Vector{T}}: Array of measurement vectors for each agent, where Y[i] represents the measurement vector for agent i.\nR::Matrix{T}: Quadratic matrix capturing the interaction between agents.\nr::Vector{T}: Vector representing the linear term for the control policies.\nc::T: Constant term for the objective function.\n\nSample Data\n\nIn the quadratic team decision problem, a sample represents a specific data point with measurements, quadratic matrices, and linear and constant terms. These samples are used to estimate the performance and optimize the control policies.\n\nThe sample data includes the following components:\n\nmathbfY: Array of measurement vectors for each agent, where Y[i] represents the measurement vector for agent i.\nmathbfR: Hermitian Positive Definite matrix capturing the interaction between agents. It represents the quadratic term for the control policies.\nmathbfr: Vector representing the linear term for the control policies.\nmathbfc: Constant term for the objective function.\n\n\n\n\n\n","category":"type"},{"location":"problemUtils/#Functions","page":"General Utility Functions","title":"Functions","text":"","category":"section"},{"location":"problemUtils/","page":"General Utility Functions","title":"General Utility Functions","text":"checkProblem(p::QuadTeamProblem)\ncheckSample(p::QuadTeamProblem, s::Sample)\ncheckGamma(P::QuadTeamProblem, γ::Vector{<:Function})\ncheckData(p::QuadTeamProblem, S::Vector{<:Sample})\nloss(s::Sample, γ::Vector{<:Function})\nrisk(S::Vector{<:Sample}, γ::Vector{<:Function})\nsplitSampleIntoBlocks(p::QuadTeamProblem, s::Sample)\nsplitDataSetIntoBlocks(p::QuadTeamProblem, S::Vector{<:Sample})","category":"page"},{"location":"problemUtils/#QuadraticTeamDecisionSolver.checkProblem-Tuple{QuadTeamProblem}","page":"General Utility Functions","title":"QuadraticTeamDecisionSolver.checkProblem","text":"checkProblem(p::QuadTeamProblem)\n\nCheck the consistency and correctness of a QuadTeamProblem object p.\n\nArguments\n\np::QuadTeamProblem: The QuadTeamProblem object representing the problem specification.\n\nErrors\n\nAssertionError: Throws an error if the problem specification is incorrect or inconsistent.\n\nExample\n\nP = QuadTeamProblem(...)\ncheckProblem(P)\n\n\n\n\n\n","category":"method"},{"location":"problemUtils/#QuadraticTeamDecisionSolver.checkSample-Tuple{QuadTeamProblem, Sample}","page":"General Utility Functions","title":"QuadraticTeamDecisionSolver.checkSample","text":"checkSample(p::QuadTeamProblem, s::Sample)\n\nCheck the consistency and correctness of a Sample object s with respect to a QuadTeamProblem p.\n\nAdditionally checks samples of mathbfR(mathbfX) are Hermitian and positive definite.\n\nArguments\n\np::QuadTeamProblem: The QuadTeamProblem object representing the problem specification.\ns::Sample: The Sample object to be checked.\n\nErrors\n\nAssertionError: Throws an error if any inconsistency or mismatch is found in the sample, or if R isn't positive definite \n\nExample\n\nP = QuadTeamProblem(...)\ns = Sample(...)\ncheckSample(P, s)\n\n\n\n\n\n","category":"method"},{"location":"problemUtils/#QuadraticTeamDecisionSolver.checkGamma-Tuple{QuadTeamProblem, Vector{<:Function}}","page":"General Utility Functions","title":"QuadraticTeamDecisionSolver.checkGamma","text":"checkGamma(P::QuadTeamProblem, γ::Vector{<:Function})\n\nCheck the output dimensions of the functions γ for each agent in the QuadTeamProblem P.\n\nArguments\n\nP::QuadTeamProblem: The QuadTeamProblem specifying the problem.\nγ::Vector{Function}: Vector of functions γ for each agent.\n\nReturns\n\nγ::Vector{Function}: The input vector of functions γ.\n\nErrors\n\nThrows an error if the output dimensions of the functions γ do not match the specified dimensions in P.\n\n\n\n\n\n","category":"method"},{"location":"problemUtils/#QuadraticTeamDecisionSolver.checkData-Tuple{QuadTeamProblem, Vector{<:Sample}}","page":"General Utility Functions","title":"QuadraticTeamDecisionSolver.checkData","text":"checkData(p::QuadTeamProblem, S::Vector{<:Sample})\n\nCheck the validity of a vector of Sample data for a given QuadTeamProblem p.\n\nArguments\n\np::QuadTeamProblem: The QuadTeamProblem specifying the problem.\nS::Vector{Sample}: Vector of Sample data to be checked.\n\nReturns\n\nresult::Vector{Sample}: A vector of Sample data with validity checks applied.\n\n\n\n\n\n","category":"method"},{"location":"problemUtils/#QuadraticTeamDecisionSolver.loss-Tuple{Sample, Vector{<:Function}}","page":"General Utility Functions","title":"QuadraticTeamDecisionSolver.loss","text":"loss(s::Sample, γ::Vector{<:Function})\n\nCompute the loss function for a given Sample s using a vector of functions γ.\n\nArguments\n\ns::Sample: The Sample data.\nγ::Vector{Function}: Vector of functions specifying the control policies.\n\nReturns\n\nloss::Real: The computed loss value.\n\n\n\n\n\n","category":"method"},{"location":"problemUtils/#QuadraticTeamDecisionSolver.risk-Tuple{Vector{<:Sample}, Vector{<:Function}}","page":"General Utility Functions","title":"QuadraticTeamDecisionSolver.risk","text":"risk(S::Vector{<:Sample}, γ::Vector{<:Function})\n\nCompute the risk function for a given vector of Samples S using a vector of functions γ.\n\nArguments\n\nS::Vector{Sample}: Vector of Sample data.\nγ::Vector{Function}: Vector of functions specifying the control policies.\n\nReturns\n\nrisk::Real: The computed risk value.\n\n\n\n\n\n","category":"method"},{"location":"problemUtils/#QuadraticTeamDecisionSolver.splitSampleIntoBlocks-Tuple{QuadTeamProblem, Sample}","page":"General Utility Functions","title":"QuadraticTeamDecisionSolver.splitSampleIntoBlocks","text":"splitSampleIntoBlocks(p::QuadTeamProblem, s::Sample)\n\nSplit a sample s into blocks based on the dimensions defined in the QuadTeamProblem p.\n\nArguments\n\np::QuadTeamProblem: A QuadTeamProblem object defining the dimensions of the blocks.\ns::Sample: A Sample object to be split into blocks.\n\nReturns\n\nR_blocks::Vector{SubArray}: An array of subarrays containing the blocks of s.R based on the block dimensions defined in p.\nr_blocks::Vector{SubArray}: An array of subarrays containing the blocks of s.r based on the block dimensions defined in p.\n\n\n\n\n\n","category":"method"},{"location":"problemUtils/#QuadraticTeamDecisionSolver.splitDataSetIntoBlocks-Tuple{QuadTeamProblem, Vector{<:Sample}}","page":"General Utility Functions","title":"QuadraticTeamDecisionSolver.splitDataSetIntoBlocks","text":"splitDataSetIntoBlocks(p::QuadTeamProblem, S::Vector{<:Sample})\n\nSplit a vector of samples S into blocks based on the dimensions defined in the QuadTeamProblem p.\n\nArguments\n\np::QuadTeamProblem: A QuadTeamProblem object defining the dimensions of the blocks.\nS::Vector{<:Sample}: A vector of Sample objects to be split into blocks.\n\nReturns\n\nY: vector of length N (number of agents) of vectors Y[i] of length m (number of samples).\n\nEach entry of Y is the vector of measurement vectors that correspond to the agent i.\n\nR_blocks: vector of length N (number of agents) of vectors R of length m (number of samples). \n\nEach entry of R, R[i] is a vector of the blocks of R that correspond to the agent i \n\nr_blocks: vector of length N (number of agents) of vectors r of length m (nummber of samples).\n\nEach entry of r, r[i] is a vector of the block of r that corresponds to the agent i\n\n\n\n\n\n","category":"method"},{"location":"#QuadraticTeamDecisionSolver.jl-Documentation","page":"Home","title":"QuadraticTeamDecisionSolver.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#General-Problem-Description","page":"Home","title":"General Problem Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The quadratic team decision problem aims to optimize a team of agents' actions to minimize a quadratic objective function. The problem can be formulated as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Minimize:","category":"page"},{"location":"","page":"Home","title":"Home","text":"J(gamma) = mathbbE_mathbfX left sum_ij = 1^N gamma^i(mathbfY_i)^top mathbfR_ij(mathbfX) gamma^j (mathbfY_j)+ 2 Re left( sum_i = 1^N gamma^j (mathbfY_j)^top mathbfr_i(mathbfX)  right) + mathbfc(mathbfX) right","category":"page"},{"location":"","page":"Home","title":"Home","text":"where:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathbfX is a random variable representing the state of the world, which is not directly accessible to the agents.\nmathbfY_i is the random variable the agent i measures. It has realizations in mathbbF^m_i.\ngamma_i(mathbfY_i) is the control policy function for agent i that maps a realization of mathbfY_i to the action mathbfU_i in mathbbF^a_i taken by agent i\nmathbfc(mathbfX) is a scalar valued random variable that depends on mathbfX.\nmathbfR_ij(mathbfX) is the matrix capturing the quadratic term for the interaction between agent i and agent j, which depends on the state mathbfX. It has realizations in mathcalL(mathbbF^a_j mathbbF^a_i).","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
